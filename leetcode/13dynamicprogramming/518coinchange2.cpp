#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
/***************************************************************************

给定不同⾯额的硬币和⼀个总⾦额。写出函数来计算可以凑成总⾦额的硬币组合数。假设每⼀种⾯额的硬币有⽆限个。
示例 1:
输⼊: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种⽅式可以凑成总⾦额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
示例 2:
输⼊: amount = 3, coins = [2]
输出: 0
解释: 只⽤⾯额2的硬币不能凑成总⾦额3。
示例 3:
输⼊: amount = 10, coins = [10]
输出: 1

这是⼀道典型的背包问题，⼀看到钱币数量不限，就知道这是⼀个完全背包。
对完全背包还不了解的同学，可以看这篇： 动态规划：关于完全背包，你该了解这些！
但本题和纯完全背包不⼀样， 纯完全背包是能否凑成总⾦额，⽽本题是要求凑成总⾦额的个数！
注意题⽬描述中是凑成总⾦额的硬币组合数，为什么强调是组合数呢？
例如示例⼀：
5 = 2 + 2 + 1
5 = 2 + 1 + 2
这是⼀种组合，都是 2 2 1。
如果问的是排列数，那么上⾯就是两种排列了。
组合不强调元素之间的顺序，排列强调元素之间的顺序。 其实这⼀点我们在讲解回溯算法专题的时候就
讲过了哈。
那我为什么要介绍这些呢，因为这和下⽂讲解遍历顺序息息相关!
回归本题，动规五步曲来分析如下：
1. 确定dp数组以及下标的含义
dp[j]：凑成总⾦额j的货币组合数为dp[j]
2. 确定递推公式
dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。
所以递推公式： dp[j] += dp[j - coins[i]];
这个递推公式⼤家应该不陌⽣了，我在讲解01背包题⽬的时候在这篇动态规划：⽬标和！ 中就讲解了，
求装满背包有⼏种⽅法，⼀般公式都是： dp[j] += dp[j - nums[i]];
3. dp数组如何初始化
⾸先dp[0]⼀定要为1， dp[0] = 1是 递归公式的基础。
从dp[i]的含义上来讲就是，凑成总⾦额0的货币组合数为1。
下标⾮0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j]
4. 确定遍历顺序

本题中我们是外层for循环遍历物品（钱币），内层for遍历背包（⾦钱总额），还是外层for遍历背包
（⾦钱总额），内层for循环遍历物品（钱币）呢？
我在动态规划：关于完全背包，你该了解这些！ 中讲解了完全背包的两个for循环的先后顺序都是可以
的。
但本题就不⾏了！
因为纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，即：有顺序也⾏，没有顺
序也⾏！
⽽本题要求凑成总和的组合数，元素之间要求没有顺序。
所以纯完全背包是能凑成总结就⾏，不⽤管怎么凑的。
本题是求凑出来的⽅案个数，且每个⽅案个数是为组合数。
那么本题，两个for循环的先后顺序可就有说法了。
我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（⾦钱总额）的情况。
代码如下：
假设： coins[0] = 1， coins[1] = 5。
那么就是先把1加⼊计算，然后再把5加⼊计算，得到的⽅法数量只有{1, 5}这种情况。⽽不会出现{5, 1}
的情况。
所以这种遍历顺序中dp[j]⾥计算的是组合数！
如果把两个for交换顺序，代码如下：
背包容量的每⼀个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。
此时dp[j]⾥算出来的就是排列数！
可能这⾥很多同学还不是很理解， 建议动⼿把这两种⽅案的dp数组数值变化打印出来，对⽐看⼀看！
（实践出真知）
5. 举例推导dp数组
输⼊: amount = 5, coins = [1, 2, 5] ， dp

**************************************************************************/
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};

int main()
{
    vector<int> nums = {1, 2, 5};
    Solution ab;
    int res = ab.change(5, nums);
    cout << "res is : " << res << endl;
    cout << "hello " << endl;
    return 0;
}

