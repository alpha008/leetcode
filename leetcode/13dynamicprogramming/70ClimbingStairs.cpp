#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
using namespace std;
/***********************************************************************************
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的⽅法可以爬到楼顶呢？
注意：给定 n 是⼀个正整数。

示例 1：
输⼊： 2
输出： 2
解释： 有两种⽅法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
示例 2：
输⼊： 3
输出： 3
解释： 有三种⽅法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
改为：⼀步⼀个台阶，两个台阶，三个台阶， .......，直到 m个台阶。问有多少种不同的⽅法可以爬到楼
顶呢？
1阶， 2阶， .... m阶就是物品，楼顶就是背包。
每⼀阶可以重复使⽤，例如跳了1阶，还可以继续跳1阶。
问跳到楼顶有⼏种⽅法其实就是问装满背包有⼏种⽅法。
此时⼤家应该发现这就是⼀个完全背包问题了！
和昨天的题⽬动态规划： 377. 组合总和 Ⅳ基本就是⼀道题了。
动规五部曲分析如下：
1. 确定dp数组以及下标的含义
dp[i]：爬到有i个台阶的楼顶，有dp[i]种⽅法。
2. 确定递推公式
在动态规划： 494.⽬标和 、 动态规划： 518.零钱兑换II、 动态规划： 377. 组合总和 Ⅳ中我们都讲过了，
求装满背包有⼏种⽅法，递推公式⼀般都是dp[i] += dp[i - nums[j]];
本题呢， dp[i]有⼏种来源， dp[i - 1]， dp[i - 2]， dp[i - 3] 等等，即： dp[i - j]
那么递推公式为： dp[i] += dp[i - j]
3. dp数组如何初始化
既然递归公式是 dp[i] += dp[i - j]，那么dp[0] ⼀定为1， dp[0]是递归中⼀切数值的基础所在，如果dp[0]
是0的话，其他数值都是0了。
下标⾮0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的， dp[i]本身为0这样才不会影响结果
4. 确定遍历顺序
这是背包⾥求排列问题，即： 1、 2 步 和 2、 1 步都是上三个台阶，但是这两种⽅法不⼀样！
所以需将target放在外循环，将nums放在内循环。
每⼀步可以⾛多次，这是完全背包，内循环需要从前向后遍历。
5. 举例来推导dp数组
介于本题和动态规划： 377. 组合总和 Ⅳ⼏乎是⼀样的，这⾥我就不再重复举例了。
***********************************************************************************/
// 版本⼀
class Solution1 {
public:
    int climbStairs(int n) {
        if (n <= 1) return n; // 因为下⾯直接对dp[2]操作了，防⽌空指针
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) { // 注意i是从3开始的
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
class Solution {
public:
    int climbStairs(int n) {
    vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= 2; j++) { // 把m换成2，就可以AC爬楼梯这道题
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};


int main()
{
    Solution ab;
    int res = ab.climbStairs(3);
    cout << "res is " << res << endl;
    cout << "hello " << endl;
    return 0;
}